#include <stdio.h>
#include <stdlib.h>
#include "front.h"
#include "parser.h"

static void error();

/**
 * This is the example Recursive-Descent Parser in pp. 181 - 185 in the
 * textbook
 *
 * Sebesta, R. W. (2012). Concepts of Programming Languages.
 * Pearson, 10th edition.
 *
 *
 * */

/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}
 */
void expr() {
  printf("Enter <expr>\n");

  /* Parse the first term */
  term();

  /* As long as the next token is + or -, get
  the next token and parse the next term */
  while (nextToken == ADD_OP || nextToken == SUB_OP) {
    lex();
    term();
  }

  printf("Exit <expr>\n");
} /* End of function expr */

/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term() {
  printf("Enter <term>\n");
  /* Parse the first factor */
  factor();
  /* As long as the next token is * or /, get the
  next token and parse the next factor */
  while (nextToken == MULT_OP || nextToken == DIV_OP) {
    lex();
    factor();
  }
  printf("Exit <term>\n");
} /* End of function term */

/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> id | int_constant | ( <expr ) | O
 * */
void factor()
{
  printf("Enter <factor>\n");
    if (nextToken == IDENT) {
      lex();
      if (nextToken == INC_OP || nextToken == DEC_OP) {
        lex();
      }
    }

    else if (nextToken == INT_LIT) {
      lex();
    }
    else {
      if (nextToken == LEFT_PAREN) {
        lex();
        expr();
        if (nextToken == RIGHT_PAREN) {
          lex();
        } else {
          error();
        }
      }
      else {
        error();
      }
    }
  printf("Exit <factor>\n");
}

/* P ::= S */
void program() {
  printf("Enter <program>\n");
  statement();
  printf("Exit <program>\n");
}

/* S ::= V=E | read(V) | write(V) | do { S } while (C) | S;S */
void statement()
{

    if (nextToken == RIGHT_PAREN || nextToken == RIGHT_CBRACE || nextToken == EOF) {
        error();
    }

    else if (nextToken == IDENT) {
        lex();
        if (nextToken == ASSIGN_OP) {
            lex();
            expr();
        } else {
            error();
        }
    }
    else if (nextToken == KEY_READ || nextToken == KEY_WRITE) {
        lex();
        if (nextToken == LEFT_PAREN) {
            lex();
            if (nextToken == IDENT) {
                lex();
                if (nextToken == RIGHT_PAREN) {
                    lex();
                } else {
                    error();
                }
            } else {
                error();
            }
        } else {
            error();
        }
    }

    else if (nextToken == KEY_DO) {
        lex();
        if (nextToken == LEFT_CBRACE) {
            lex();
            statement();
            if (nextToken == RIGHT_CBRACE) {
                lex();
                if (nextToken == KEY_WHILE) {
                    lex();
                    if (nextToken == LEFT_PAREN) {
                        lex();
                        condition();
                        if (nextToken == RIGHT_PAREN) {
                            lex();
                        } else {
                            error();
                        }
                    } else {
                        error();
                    }
                } else {
                    error();
                }
            } else {
                error();
            }
        } else {
            error();
        }
    }
    else {
        error();
    }


    // S;S
    if (nextToken == SEMICOLON) {
        lex();
        statement();
    }
}


/* C ::= E < E | E > E | E == E | E != E | E <= E | E >= E */
void condition() {
  printf("Enter <condition>\n");
  expr();
  int relop = nextToken;
  if (relop == LESSER_OP || relop == GREATER_OP || relop == EQUAL_OP ||
      relop == NEQUAL_OP || relop == LEQUAL_OP || relop == GEQUAL_OP) {
    lex(); /* Get the next token */
    expr();
  } else {
    error();
  }
  printf("Exit <condition>\n");
}

static void error() {
  printf("Error encountered: The next lexeme was %s and the next token was %s", lexeme, tokennames);
  //syntaxError = 1;
  exit(1);
}